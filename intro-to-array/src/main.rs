///
/// # 配列
///
/// ## 配列: `[T; n]`
///
/// - `T`: 要素型
/// - `n`: 非負整数
///
/// 配列は長さを型に含む。
///
/// Rust の配列のインデックスは境界チェックされる。
///
/// ## スライス: `[T]`
///
/// スライスは長さを型に含まない。
/// しかし、配列と同じく、拡大も縮小もしない。
/// サイズが「動的」とは、「サイズが変動する」のではなく「動的な型付け」の意味である。
/// 配列はサイズを型に含むため配列のトレイトを実装するのは大変、そこでスライスに対してトレイトを実装し、配列からスライスを生成すれば簡単かつ安価である。
///
/// スライスは配列のビュー（view）である。
/// スライスを使えば、コピーなしに、データを高速に読み込み専用でアクセスできる。
///
/// スライスはその定義上、コンパイル時にサイズが分からない。
/// そこで参照（`&[T]`）が役に立つ。
/// スライスのサイズはメモリ上に固定されるが、その実装はポインタと長さという2つの `usize` コンポーネントで構成される
///
fn main() {
    let one = [1, 2, 3];
    let two: [u8; 3] = [1, 2, 3];
    let blank1 = [0; 3];
    let blank2: [u8; 3] = [0; 3];

    let arrays = [one, two, blank1, blank2];

    for a in &arrays {
        print!("{:?}: ", a);
        for n in a.iter() {
            print!("\t{} + 10 = {}", n, n + 10);
        }

        let mut sum = 0;
        for i in 0..a.len() {
            sum += a[i];
        }
        println!("\t(Σ {:?} = {})", a, sum);
    }
}
